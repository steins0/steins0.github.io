<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="833," />










<meta name="description" content="线性表线性表的概念 线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列  线性表的操作主要操作：   123456初始化 Initlist()销毁 droplist()插入 insertlist()删除 deletelist()按值查找 findbyvalue()按位查找  findbylocat() 其他操作： 123求表长输出判空（isempty） 顺序表存储结构逻辑相邻+地址相邻 实">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构提纲">
<meta property="og:url" content="http://yoursite.com/2020/11/12/review/index.html">
<meta property="og:site_name" content="steins">
<meta property="og:description" content="线性表线性表的概念 线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列  线性表的操作主要操作：   123456初始化 Initlist()销毁 droplist()插入 insertlist()删除 deletelist()按值查找 findbyvalue()按位查找  findbylocat() 其他操作： 123求表长输出判空（isempty） 顺序表存储结构逻辑相邻+地址相邻 实">
<meta property="og:image" content="http://yoursite.com/images/string/str-1.png">
<meta property="og:image" content="http://yoursite.com/images/string/str-2.png">
<meta property="og:image" content="http://yoursite.com/images/structure/tree-1.png">
<meta property="og:image" content="http://yoursite.com/images/structure/6-1.png">
<meta property="og:image" content="http://yoursite.com/images/structure/6-1.png">
<meta property="og:image" content="http://yoursite.com/images/structure/7-0.png">
<meta property="og:image" content="http://yoursite.com/images/structure/7-1.png">
<meta property="og:image" content="http://yoursite.com/images/structure/7-2.png">
<meta property="og:image" content="http://yoursite.com/images/structure/7-2.png">
<meta property="og:image" content="http://yoursite.com/images/structure/9-1.PNG">
<meta property="og:image" content="http://yoursite.com/images/structure/9-2.PNG">
<meta property="og:image" content="http://yoursite.com/images/structure/9-3.png">
<meta property="og:image" content="http://yoursite.com/images/structure/9-4.png">
<meta property="og:image" content="http://yoursite.com/images/structure/9-5.png">
<meta property="og:image" content="http://yoursite.com/images/structure/9-5.png">
<meta property="article:published_time" content="2020-11-12T10:00:28.000Z">
<meta property="article:modified_time" content="2020-12-14T11:40:35.089Z">
<meta property="article:author" content="Steins.lei">
<meta property="article:tag" content="833">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/string/str-1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/11/12/review/"/>





  <title>数据结构提纲 | steins</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">steins</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">杯中收纳了虚空倒影，畅饮这一弘蓝天白云</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/12/review/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Steins.lei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/own/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="steins">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构提纲</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-11-12T18:00:28+08:00">
                2020-11-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/2020-autumn/" itemprop="url" rel="index">
                    <span itemprop="name">2020-autumn</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="线性表的概念"><a href="#线性表的概念" class="headerlink" title="线性表的概念"></a>线性表的概念</h3><ul>
<li>线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列</li>
</ul>
<h3 id="线性表的操作"><a href="#线性表的操作" class="headerlink" title="线性表的操作"></a>线性表的操作</h3><p>主要操作：  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">初始化 Initlist()</span><br><span class="line">销毁 droplist()</span><br><span class="line">插入 insertlist()</span><br><span class="line">删除 deletelist()</span><br><span class="line">按值查找 findbyvalue()</span><br><span class="line">按位查找  findbylocat()</span><br></pre></td></tr></table></figure>
<p>其他操作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">求表长</span><br><span class="line">输出</span><br><span class="line">判空（isempty）</span><br></pre></td></tr></table></figure>
<h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><p>逻辑相邻+地址相邻</p>
<h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>静态表： 数组实现<br>动态表： 指针实现（malloc或者new分配空间）</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>随机访问，按位查找复杂度O(1)<br>存储密度高<br>扩展不方便<br>插入、删除不方便<br><a href="https://github.com/steins0/XDU-steins/blob/master/2020-autumn/%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/list1.cpp" target="_blank" rel="noopener"><strong>代码</strong></a></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="链表的概念"><a href="#链表的概念" class="headerlink" title="链表的概念"></a>链表的概念</h4><p>链表：用链式存储实现的存储结构<br>单链表：有尾结点<br><a href="https://github.com/steins0/XDU-steins/blob/master/2020-autumn/%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E7%BA%BF%E6%80%A7%E8%A1%A8/list2.cpp" target="_blank" rel="noopener"><strong>代码</strong></a><br>双链表：有头节点、尾结点<br>循环链表：有头节点、尾结点，且最后一个结构的尾结点指向第一个结构<br>静态链表：用数据进行实现的结构  </p>
<h3 id="顺序表与链表的比较"><a href="#顺序表与链表的比较" class="headerlink" title="顺序表与链表的比较"></a>顺序表与链表的比较</h3><ol>
<li>顺序表的优点：<br>支持随机存取、存储密度高</li>
<li>顺序表的缺点：<br>大片连续空间分配不方便，改变容量不方便</li>
<li>链表的优点：<br>离散的小空间分配方便，改变容量方便  </li>
<li>链表的缺点：<br>不可随机存取，存储密度低<br>顺序表和链表的逻辑结构都是线性结构，都属于线性表。但是二者的存储结构不同，顺序表采用顺序存储(特点，带来的优点缺点)；链表采用链式存储（特点、导致的优缺点）。由于采用不同的存储方式实现，因此基本操作的实现效率也不同。</li>
</ol>
<h2 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h2><h3 id="基础概念与基本操作"><a href="#基础概念与基本操作" class="headerlink" title="基础概念与基本操作"></a>基础概念与基本操作</h3><h4 id="栈的概念（stack）"><a href="#栈的概念（stack）" class="headerlink" title="栈的概念（stack）"></a>栈的概念（stack）</h4><ul>
<li>栈是只允许在一端进行插入或删除操作的<strong>线性表</strong><br>特性：<blockquote>
<p>后进先出  </p>
</blockquote>
</li>
</ul>
<p>重要词汇：  </p>
<blockquote>
<p>栈顶:允许插入和删除的一端<br>栈顶元素：栈顶位置的元素<br>栈底:不允许插入和删除的一端<br>空栈:没有元素的栈</p>
<h4 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化栈：initstack()</span><br><span class="line">销毁栈：dropstack()</span><br><span class="line">进栈：push()</span><br><span class="line">出栈：pop()</span><br><span class="line">返回栈顶元素：gettop()<span class="comment">//与出栈相比不消除栈顶元素——栈大小不变</span></span><br></pre></td></tr></table></figure>
<h4 id="队列的概念（stack）"><a href="#队列的概念（stack）" class="headerlink" title="队列的概念（stack）"></a>队列的概念（stack）</h4><ul>
<li>队列（Queue）是只允许在一端进行插入，在另一端删除的<strong>线性表</strong>  </li>
</ul>
</blockquote>
<p>特性：  </p>
<blockquote>
<p>先进先出<br>重要词汇：<br>队头:允许删除的一端<br>队头元素：队头位置的元素<br>队尾:允许插入的一端<br>队尾元素：队尾位置的元素<br>空队列:没有元素的队列</p>
<h4 id="队列的基本操作"><a href="#队列的基本操作" class="headerlink" title="队列的基本操作"></a>队列的基本操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化队列：initqueue()</span><br><span class="line">销毁队列：dropqueue()</span><br><span class="line">进队：enqueue()</span><br><span class="line">出队：outqueue()</span><br><span class="line">返回队头元素：gettop()<span class="comment">//与出队相比不消除对头元素——队列大小不变</span></span><br></pre></td></tr></table></figure>
<h3 id="顺序存储结构与链式存储结构"><a href="#顺序存储结构与链式存储结构" class="headerlink" title="顺序存储结构与链式存储结构"></a>顺序存储结构与链式存储结构</h3><h4 id="栈的顺序存储结构与链式存储结构"><a href="#栈的顺序存储结构与链式存储结构" class="headerlink" title="栈的顺序存储结构与链式存储结构"></a>栈的顺序存储结构与链式存储结构</h4><p><a href="https://github.com/steins0/XDU-steins/blob/master/2020-autumn/%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/stack.cpp" target="_blank" rel="noopener">代码</a>  </p>
<h4 id="队列的顺序存储结构与链式存储结构"><a href="#队列的顺序存储结构与链式存储结构" class="headerlink" title="队列的顺序存储结构与链式存储结构"></a>队列的顺序存储结构与链式存储结构</h4><p><a href="https://github.com/steins0/XDU-steins/blob/master/2020-autumn/%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/queue.cpp" target="_blank" rel="noopener">代码</a></p>
</blockquote>
<h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3><h4 id="栈的应用一——括号匹配"><a href="#栈的应用一——括号匹配" class="headerlink" title="栈的应用一——括号匹配"></a>栈的应用一——括号匹配</h4><ul>
<li>用栈实现括号匹配：<br>依次扫描所有字符，遇到左括号入栈，遇到右括号则弹出栈顶元素检否匹配。  </li>
<li>匹配失败情况：<br>①左括号单身<br>②右括号单身<br>③左右括号不匹配<h4 id="栈的应用二——算式求值"><a href="#栈的应用二——算式求值" class="headerlink" title="栈的应用二——算式求值"></a>栈的应用二——算式求值</h4></li>
<li>逆波兰表达式=后缀表达式<br>正常的表达式：运算符在操作数之后<blockquote>
<p>操作数1  操作数2 运算符<br>1+1 =》1 1 +  &emsp;1+2<em>3=》123\</em>+</p>
</blockquote>
</li>
<li>波兰表达式=前缀表达式<br>正常的表达式：运算符在操作数之前<blockquote>
<p>运算符 操作数1  操作数2<br>1+1=》+11  &emsp;1+2<em>3=》+1\</em>23</p>
</blockquote>
</li>
<li>中缀表达式：<br>正常的表达式：运算符在操作数之间<blockquote>
<p>操作数1 运算符 操作数2<br>1+1  &emsp;1+2*3  </p>
</blockquote>
</li>
</ul>
<ol>
<li><p>用栈实现后缀表达式的计算：<br>①从左往右扫描下一个元素，直到处理完所有元素<br>②若扫描到操作数则压入栈，并回到①；否则执行③<br>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①  </p>
</li>
<li><p>用栈实现前缀表达式的计算：<br>①从右往左扫描下一个元素，直到处理完所有元素<br>②若扫描到操作数则压入栈，并回到①；否则执行③<br>③若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到①  </p>
</li>
<li><p>用栈实现中缀转后缀：<br>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。<br>从左到右处理各个元素，直到末尾。可能遇到三种情况：<br>① 遇到操作数。直接加入后缀表达式。<br>② 遇到界限符。遇到“(”直接入栈；遇到“)”则依次弹出栈内运算符并加入后缀表达式，直到<br>弹出“(”为止。注意：“(”不加入后缀表达式。<br>③ 遇到运算符。依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，<br>若碰到“(” 或栈空则停止。之后再把当前运算符入栈。<br>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。  </p>
<h4 id="栈的应用三——递归"><a href="#栈的应用三——递归" class="headerlink" title="栈的应用三——递归"></a>栈的应用三——递归</h4><h4 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h4></li>
<li>树的层次遍历</li>
<li>图的广度优先搜索</li>
<li>操作系统的先来先去服务FCFS</li>
</ol>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><h3 id="串的概率和操作"><a href="#串的概率和操作" class="headerlink" title="串的概率和操作"></a>串的概率和操作</h3><h4 id="串的基本概念"><a href="#串的基本概念" class="headerlink" title="串的基本概念"></a>串的基本概念</h4><ul>
<li>串，即字符串（String）是由零个或多个字符组成的有限序列。一般记为S = ‘a<sub>1</sub>a<sub>2</sub>······a<sub>n</sub>‘ （n ≥0）  </li>
<li>其中，S是串名，单引号括起来的字符序列是串的值；ai可以是字母、数字或其他字符；  </li>
<li>串中字符的个数n称为串的长度。  </li>
<li>n = 0时的串称为空串（用∅表示）。</li>
</ul>
<blockquote>
<p>子串：串中任意个连续的字符组成的子序列。<br>主串：包含子串的串。<br>字符在主串中的位置：字符在串中的序号。<br>子串在主串中的位置：子串的第一个字符在主串中的位置  </p>
<h4 id="串的基本操作"><a href="#串的基本操作" class="headerlink" title="串的基本操作"></a>串的基本操作</h4><h3 id="串的匹配"><a href="#串的匹配" class="headerlink" title="串的匹配"></a>串的匹配</h3><p>pat:  用于匹配的字符串  对应子字符位置j<br>txt： 被匹配的字符串  对应子字符位置i  </p>
<h4 id="朴素匹配"><a href="#朴素匹配" class="headerlink" title="朴素匹配"></a>朴素匹配</h4><p>暴力匹配<br>每个i都从头开始一次关于pat的匹配</p>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><ol>
<li>主要思路：<br>求解一个用于字符串pat信息的数据——next<br>如果p[j]位置与t[i]位置匹配失败，next会告诉我们pat字符串应该前进多少位置（当前位置在下一步应该用pat哪一个位置的来比较）<br>匹配成功或者首字符就不匹配都会使两个串的位置均前进  </li>
<li>主要表示：<br>表示被匹配的字符串的位置i不会回退<br>j==0 是表示当前字符与第一个字符不匹配，因此ij++</li>
<li>next数据求解<br>假设pat = ABCDABD<br>3.1 常规方法<br>找前缀子串和后缀子串的最大公共元素长度<br><img src="/images/string/str-1.png" alt="alt"><br>next为最大公共元素长度的后移且每项+1<br>首字符置零<br>3.2 状态机<br><img src="/images/string/str-2.png" alt="alt">  <h4 id="KMP优化"><a href="#KMP优化" class="headerlink" title="KMP优化"></a>KMP优化</h4></li>
<li>需要优化的地方：<br>以自动机为例，在上面例子中，状态6匹配字符若为other，则跳转状态2，此时字符会与2的状态在进行一次检测，这两次检测可以简化为单次检测</li>
<li>优化方式</li>
</ol>
</blockquote>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p><a href="https://github.com/steins0/XDU-steins/blob/master/2020-autumn/%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%AD%97%E7%AC%A6%E4%B8%B2/KMP.cpp" target="_blank" rel="noopener">字符串</a></p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="树-1"><a href="#树-1" class="headerlink" title="树"></a>树</h3><h4 id="树的基本概念"><a href="#树的基本概念" class="headerlink" title="树的基本概念"></a>树的基本概念</h4><ul>
<li>树是n（n≥0）个结点的有限集合，n = 0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：<br>1）有且仅有一个特定的称为根的结点。<br>2）当n &gt; 1时，其余结点可分为m（m &gt; 0）个互不相交的有限集合T1, T2,…, Tm，其中每个集合本身又是一棵树，并且称为根结点的子树。<h4 id="节点之间的关系"><a href="#节点之间的关系" class="headerlink" title="节点之间的关系"></a>节点之间的关系</h4></li>
</ul>
<ul>
<li>父节点（双亲节点),孩子节点</li>
<li>祖先节点，子孙节点</li>
<li>兄弟节点，堂兄弟节点</li>
<li>节点之间的路径</li>
<li>路径长度</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A --&gt; B</span><br><span class="line">    B --&gt; C</span><br><span class="line">    C --&gt; E</span><br><span class="line">    C --&gt; D</span><br></pre></td></tr></table></figure>
<h4 id="节点、树的属性"><a href="#节点、树的属性" class="headerlink" title="节点、树的属性"></a>节点、树的属性</h4><ul>
<li>节点的深度（层次）：从1开始，从上往下数</li>
<li>节点的高度：从1开始，从下往上数</li>
<li>树的深度：最大的层数</li>
<li>节点的度：子女的分支数</li>
<li>树的度：各节点中最大的度</li>
</ul>
<h4 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h4><ol>
<li>总节点数 = 总度数 + 1</li>
<li>度为m的树<ul>
<li>至少有一个节点度为m</li>
<li>一定是非空树</li>
</ul>
</li>
<li>m叉树<ul>
<li>所有节点的度小于m</li>
<li>可以是空树</li>
</ul>
</li>
<li>节点数：<ul>
<li>度为m的树第i层最多有<strong>m</strong><sup><strong>i-1</strong></sup>个节点</li>
<li>高度为h的m叉树最多有  $\frac{m^h-1}{m-1}$</li>
<li>高度为h的m叉树最少有<strong>h</strong>个节点</li>
<li>高度为h，度为m的树最少有<em>h+m-1</em>个节点</li>
</ul>
</li>
<li>具有n个结点的m叉树的最小高度为$\log_m(n(m-1)+1)$</li>
</ol>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h4 id="二叉树的基本概念"><a href="#二叉树的基本概念" class="headerlink" title="二叉树的基本概念"></a>二叉树的基本概念</h4><ul>
<li>二叉树是n（n≥0）个结点的有限集合：<br>① 或者为空二叉树，即n = 0。<br>② 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。<br>左子树和右子树又分别是一棵二叉树。<br>特点：<br>①每个结点至多只有两棵子树<br>②左右子树不能颠倒（二叉树是有序树）</li>
</ul>
<h4 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h4><ol>
<li>满二叉树:高度为h，节点数为2<sup>h</sup>-1的二叉树</li>
<li>完全二叉树：在满二叉树中最下一层，连续删除若干个节点得到完全二叉树。</li>
<li>二叉排序树：左子树关键值 &lt; 根节点关键值 &lt; 右子树关键值</li>
<li>平衡二叉树：树上任一结点的左子树和右子树的深度之差不超过1。  </li>
</ol>
<ul>
<li>满二叉树是一棵特殊的完全二叉树，但完全二叉树不一定是满二叉树。</li>
</ul>
<h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><ol>
<li>设非空二叉树中度为0、1和2的结点个数分别为n<sub>0</sub>、n<sub>1</sub>和n<sub>2</sub>，总节点为n<ul>
<li>n = n<sub>0</sub> + n<sub>1</sub> + n<sub>2</sub> —- ①</li>
<li>n = n<sub>1</sub> + 2*n<sub>2</sub> + 1 (节点数 = 总度数 + 1 ) —-②</li>
<li>n<sub>0</sub> = n<sub>2</sub> + 1   —-由①②推出</li>
</ul>
</li>
<li>节点数：<ul>
<li>二叉树第i层最多有<strong>2</strong><sup><strong>i-1</strong></sup>个节点   满二叉树</li>
<li>高度为h的二叉树至多有2ℎ − 1个结点   满二叉树</li>
</ul>
</li>
<li>具有n个（n &gt; 0）结点的完全二叉树的高度h为$\log_2(n+1)$</li>
</ol>
<h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><ol>
<li><p>线性存储</p>
<blockquote>
<p> 定义一个长度为 MaxSize 的数组 t ，按照从上至下、从左至右的顺序依次存储完全二叉树中的各个结点<br>对于第i个节点</p>
<blockquote>
<p>i的左孩子——2i<br>i的右孩子——2i+1<br>i的父节点——$\frac{i}{2}$<br>i所在层数——$\log_2(n+1)$  </p>
</blockquote>
<p>缺陷：非完全二叉树会有许多空节点，造成空间浪费  </p>
</blockquote>
</li>
<li><p>链式存储</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">treenode</span>&#123;</span></span><br><span class="line">   ELemtype data;</span><br><span class="line">   treenode *rchild, * lchild;</span><br><span class="line">   <span class="comment">//可选头节点</span></span><br><span class="line">   treenode *parent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">treenode</span> *<span class="title">treenodes</span>;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>&emsp;<strong>1-3实现过程：递归</strong></p>
<ol>
<li>先序遍历：根左右  </li>
<li>中序遍历：左根右  </li>
<li><p>后序遍历：左右根  </p>
</li>
<li><p>层次遍历:<br>算法思想：<br>①. 初始化一个辅助队列<br>②. 根结点入队<br>③. 若队列非空，则队头结点出队，访问该结点，并将其左、右孩子插入队尾（如果有的话）<br>④. 重复③直至队列为空<br><img src="/images/structure/tree-1.png" alt="alt">  </p>
</li>
</ol>
<h4 id="线索二叉树的基本概念和构造"><a href="#线索二叉树的基本概念和构造" class="headerlink" title="线索二叉树的基本概念和构造"></a>线索二叉树的基本概念和构造</h4><ul>
<li><strong>前驱</strong>：<br>在二叉树中，有（左子树为空）节点，遍历过程中，在该节点之前遍历的一个节点为前驱（若该节点为遍历的第一个节点，则前驱为NULL）  </li>
<li><strong>后继</strong>：<br>在二叉树中，有（右子树为空）节点，遍历过程中，在该节点之后遍历的一个节点为后继（若该节点为遍历的最后一个节点，则后继为NULL）  </li>
<li><strong>线索二叉树</strong>：<br>一个二叉树，在最底层的节点中他的左子树节点指向他的前驱，右子树节点指向后继，最后形成的数据结构（依据先/中/后序遍历的不同，生成的线索二叉树不同）</li>
</ul>
<h3 id="树、森林"><a href="#树、森林" class="headerlink" title="树、森林"></a>树、森林</h3><h4 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h4><p>以此树为例<img src="/images/structure/6-1.png" alt="alt"></p>
<ol>
<li>双亲表示法（顺序存储）  </li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>数组序号</th>
<th>data</th>
<th>parent</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>A</td>
<td>-1</td>
</tr>
<tr>
<td>1</td>
<td>B</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>C</td>
<td>0</td>
</tr>
<tr>
<td>3</td>
<td>D</td>
<td>0</td>
</tr>
<tr>
<td>4</td>
<td>E</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<ol>
<li>孩子表示法（链式+顺序）<br><img src="/images/structure/6-1.png" alt="alt">  </li>
<li>兄弟表示法（链式存储）  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tnode</span>&#123;</span></span><br><span class="line">   elemtype data; <span class="comment">//数据</span></span><br><span class="line">   tnode *firstchild, *nextbrother; <span class="comment">//指向第一个孩子，和右兄弟</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> tnode *tnodeds;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="树、森林、二叉树的转换"><a href="#树、森林、二叉树的转换" class="headerlink" title="树、森林、二叉树的转换"></a>树、森林、二叉树的转换</h4><p><a href="https://www.cnblogs.com/zhuyf87/archive/2012/11/04/2753950.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhuyf87/archive/2012/11/04/2753950.html</a></p>
<h3 id="哈夫曼数"><a href="#哈夫曼数" class="headerlink" title="哈夫曼数"></a>哈夫曼数</h3><p>给定n个权值分别为w,w2…wn的结点,构造哈夫曼树的算法描述如下</p>
<ol>
<li>将这n个结点分别作为n棵仅含一个结点的二叉树,构成森林F</li>
<li>构造一个新结点,从F中选取两棵根结点权值最小的树作为新结点的左、右子树,并且将新结点的权值置为左、右子树上根结点的权值之和</li>
<li>从F中删除刚才选出的两棵树,同时将新得到的树加入F中。</li>
<li>重复步骤2和3,直至F中只剩下一棵树为止</li>
</ol>
<ul>
<li>已知有n个节点，最后的哈夫曼树有2*n+1个节点</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><ul>
<li><p>概念：图是顶点集和边集组成的二元组G=<V,E>,E中每条边是V中一对顶点(u,v)间的联系,如果是无序对，那么称该图为无向图，否则为有向图。</p>
</li>
<li><p>顶点V的度 = 与V相关联的边的数目</p>
</li>
<li>在有向图中：<ul>
<li>顶点V的出度 = 以V为起点有向边数</li>
<li>顶点V的入度 = 以V为终点有向边数</li>
<li>顶点V的度 = V的出度+V的入度</li>
</ul>
</li>
<li>设图G的顶点数为n，边数为e<ul>
<li>图的所有顶点的度数之和 = 2*e</li>
</ul>
</li>
</ul>
<h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><ol>
<li>无向图的邻接矩阵是对称矩阵，同一条边表示了两次；</li>
<li>顶点v的度：等于二维数组对应行（或列）中值为1的元素个数；</li>
<li>判断两顶点v、u是否为邻接点：只需判二维数组对应分量是否为1；</li>
<li>顶点不变，在图中增加、删除边：只需对二维数组对应分量赋值1或清0；</li>
<li>设图的顶点数为 n ,用有n个元素的一维数组存储图的顶点,用邻接矩阵表示边,则G占用的存储空间为：$n+n2$；图的存储空间占用量只与它的顶点数有关，与边数无关；<strong>适用于边稠密的图</strong>；  </li>
</ol>
<p><img src="/images/structure/7-0.png" alt="alt"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ves;<span class="comment">//记录顶点信息，A.B...</span></span><br><span class="line">    <span class="keyword">int</span> **arc;<span class="comment">//边表</span></span><br><span class="line">    <span class="keyword">int</span> numberV,nueberE;</span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure></p>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><ol>
<li>邻接表表示不唯一。 </li>
<li>对于有n个顶点和e条边的无向图,其邻接表有n个头结点和2e个表结点。</li>
<li>对于无向图,邻接表的顶点vi对应的第i个链表的表结点数目正好是顶点vi的度。</li>
<li>对于有向图,邻接表的顶点vi对应的第i个链表的表结点数目仅仅是vi的出度。其入度为邻接表中所有adjvex域值为i的表结点数目。</li>
</ol>
<p><img src="/images/structure/7-1.png" alt="alt"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>&#123;</span>  <span class="comment">//边表结点</span></span><br><span class="line">   <span class="keyword">int</span> adjvex; <span class="comment">//邻接点域，存储该顶点对应的下标</span></span><br><span class="line">   EdgeType weight;  <span class="comment">//存储权值，非网图不需要</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;EdgeNode;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span>&#123;</span>  <span class="comment">//顶点表结点</span></span><br><span class="line">   VertexType data; <span class="comment">//顶点信息</span></span><br><span class="line">   EdgeNode *firstedge;  <span class="comment">//边表头指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> VertexNode AdjList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">   AdjList adjList[<span class="number">100</span>];  </span><br><span class="line">   <span class="keyword">int</span> numVertexes,numEdges; <span class="comment">//图中当前顶点数和边数</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure></p>
<h4 id="十字链表"><a href="#十字链表" class="headerlink" title="十字链表"></a>十字链表</h4><ul>
<li>用于有向图，方便计算入度与出度  </li>
</ul>
<p><img src="/images/structure/7-2.png" alt="alt">  </p>
<h4 id="邻接多重表"><a href="#邻接多重表" class="headerlink" title="邻接多重表"></a>邻接多重表</h4><ul>
<li>用于无向图</li>
</ul>
<p><img src="/images/structure/7-2.png" alt="alt">  </p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="深度优先遍历-DFS"><a href="#深度优先遍历-DFS" class="headerlink" title="深度优先遍历-DFS"></a>深度优先遍历-DFS</h4><ol>
<li>对树状结构：<ul>
<li>类似于二叉树的左右根（后序遍历）</li>
</ul>
</li>
<li>对邻接表结构：<ul>
<li>将节点顺序，依次遍历当前节点和他的所有边表信息</li>
</ul>
</li>
</ol>
<h4 id="广度优先遍历-BFS"><a href="#广度优先遍历-BFS" class="headerlink" title="广度优先遍历-BFS"></a>广度优先遍历-BFS</h4><ol>
<li>对树状结构：<ul>
<li>类似于二叉树的根左右（先序遍历）</li>
</ul>
</li>
<li>对邻接表结构：<ul>
<li>先把所有节点依次入栈</li>
<li>顶点出栈，顶点中有边表信息，将边表信息入栈</li>
<li>重复上一步至栈空</li>
</ul>
</li>
</ol>
<h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul>
<li><p>生成树：一个连通图的生成树是一个极小连通子图,它含有图中全部顶点,但只有构成一棵树的(n-1)条边。</p>
<ul>
<li>深度优先生成树: 由深度优先遍历得到的生成树；</li>
<li>广度优先生成树: 由广度优先遍历得到的生成树。</li>
<li>遍历时访问过的n个顶点和遍历时经历的n-1条边组成。</li>
<li>生成森林: 对于非连通图, 各个连通分量的生成树组成非连通图的。</li>
</ul>
</li>
<li><p>最小生成树：在一个连通网的所有生成树中， 各边的代价之和最小的那棵生成树。简称为最小生成树(MST)。 </p>
</li>
</ul>
<ol>
<li>普里姆算法 (Prim算法)   <ul>
<li>从某一个顶点开始构建生成树;每次将代价最小的新顶点纳入生成树,直到所有顶点都纳入为止。</li>
</ul>
</li>
<li>克鲁斯卡尔算法（ Kruskal 算法）<ul>
<li>所有边按照权值的大小进行升序排序，然后从小到大一一判断，条件为：如果这个边不会与之前选择的所有边组成回路，就可以作为最小生成树的一部分；反之，舍去。直到具有 n 个顶点的连通网筛选出来 n-1 条边为止。筛选出来的边和所有的顶点构成此连通网的最小生成树。</li>
<li>树的归并操作</li>
<li><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4></li>
</ul>
</li>
</ol>
<ul>
<li>用顶点表示活动， 用有向弧表示活动间的优先关系， 即上节所讨论的<strong>AOV-</strong>网。 </li>
<li>用顶点表示事件， 用弧表示活动， 弧的权值表示活动所需要的时间。带权的有向无环图叫做边表示活动的网（Activity On Edge  Network）, 简称<strong>AOE-</strong>网。 </li>
</ul>
<p>方法一：（从图中顶点的入度考虑）<br>从有向图中选择一个没有前驱(即入度为0)的顶点并且输出它。<br>从有向图中删去该顶点和所有以它为尾的弧；<br>重复上述两步,直到图全部顶点输出；或当前图中不再存在没有前驱的顶点。</p>
<h4 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h4><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><ol>
<li>Dijkstra O($N^2$)<ul>
<li>引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。一个记录节点是否有最短路径的D,一个P用来记录当前最短路径节点的前驱节点，</li>
<li>步骤一：指定开始节点start，初始化S（到自己为0，其他记录为INF——最大值），初始化U（从start开始能到达的节点）</li>
<li>步骤二：从U中找到start能到的节点k（此路径最小），将该节点加入到S</li>
<li>步骤三：更新U中的节点路径（对于一个未记录的节点i，如果start-&gt;k-&gt;i的路径小于start-&gt;i的路径，就更新U）</li>
<li>重复步骤二、三<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> count = <span class="number">1</span>; count &lt; n; count++) &#123; <span class="comment">// 要加入n-1个顶点</span></span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">-1</span>; <span class="comment">// 选出一个距离初始顶点start最近的未标记顶点</span></span><br><span class="line">            <span class="keyword">int</span> dmin = Integer.MAX_VALUE; <span class="comment">//dim为记录当前路径中的最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; weight[start][i] &lt; dmin) &#123;</span><br><span class="line">                   <span class="comment">//visit表示该节点是否被记录 = D</span></span><br><span class="line">                    dmin = weight[start][i];<span class="comment">//wight = U</span></span><br><span class="line">                    k = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新选出的顶点标记为已求出最短路径，且到start的最短路径就是dmin</span></span><br><span class="line">            shortPath[k] = dmin;</span><br><span class="line">            visited[k] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 以k为中间点，修正从start到未访问各点的距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="comment">//如果 '起始点到当前点距离' + '当前点到某点距离' &lt; '起始点到某点距离', 则更新</span></span><br><span class="line">                <span class="keyword">if</span> (visited[i] == <span class="number">0</span> &amp;&amp; weight[start][k] + weight[k][i] &lt; weight[start][i]) &#123;</span><br><span class="line">                    weight[start][i] = weight[start][k] + weight[k][i];</span><br><span class="line">                    path[i] = path[k] + <span class="string">"--&gt;"</span> + i; <span class="comment">//P</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Floyd O($N^3$)<ul>
<li>指定一个开始节点，从他能到达的第一个节点开始，不断试图增加中间节点，</li>
</ul>
</li>
</ol>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><blockquote>
<p>概念：给定一个值key，在含有n个记录的表中找出关键字等于key的记录。若找到,则查找成功，返回该记录的信息或该记录在表中的位置；否则查找失败，返回相关的指示信息。<br>主关键字：能唯一标识一个记录的关键字。<br>次关键字：能标识多个记录的关键字。<br>平均查找长度ASL(Average Search Length) ：为确定数据元素在查找表中的位置， 需和给定值进行比较的关键字个数的期望值，称为查找算法在查找成功时的平均查找长度。<br>$ASL = \sum_1^n P_i*C_i$<br>Pi为查找表中第i个记录的概率，Ci为找到第i个记录时，和给定值已经进行过比较的关键字个数。</p>
</blockquote>
<h3 id="静态查找表——基于线性表的查找法"><a href="#静态查找表——基于线性表的查找法" class="headerlink" title="静态查找表——基于线性表的查找法"></a>静态查找表——基于线性表的查找法</h3><blockquote>
<p>概念：查询某个特定的元素是否在表中；检索某个特定的元素的各种属性。</p>
<ol>
<li>顺序查找</li>
<li>折半查找（二分查找）：要求待查找的表必须是按关键字大小有序排列的顺序表。  <ul>
<li>$ASL_{折半查找} = [\log_2n]+1$<br><img src="/images/structure/9-1.PNG" alt="alt">  </li>
</ul>
</li>
<li>索引查找（分块查找）：索引表是一个递增有序表。<ul>
<li>性能介于顺序查找和折半查找之间的查找方法。</li>
<li>$ASL_{索引} = L_B+L_W(L_B为索引表序列、L_W块内序列)$</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="动态查找表——基于树表的查找法"><a href="#动态查找表——基于树表的查找法" class="headerlink" title="动态查找表——基于树表的查找法"></a>动态查找表——基于树表的查找法</h3><blockquote>
<p>概念：表结构本身在查找过程中动态生成，即对于给定值key，若表中存在关键字等于key的记录，则查找成功，否则插入关键字等于key的记录。</p>
<ol>
<li>二叉排序树BST (Binary Sort Tree)<ul>
<li>中序遍历得到顺序关键字</li>
<li><a href="https://www.cnblogs.com/sench/p/7783331.html" target="_blank" rel="noopener">https://www.cnblogs.com/sench/p/7783331.html</a></li>
</ul>
</li>
<li>平衡二叉树(AVL)<ul>
<li>平衡因子BF(Balance Factor) ：二叉树中每个结点的平衡因子是该结点左子树的高度减去右子树的高度。<br><img src="/images/structure/9-2.PNG" alt="alt"></li>
<li>左旋和右旋</li>
<li><a href="https://blog.csdn.net/isunbin/article/details/81707606" target="_blank" rel="noopener">https://blog.csdn.net/isunbin/article/details/81707606</a></li>
</ul>
</li>
<li>B-树<h3 id="哈希表——计算式查找法"><a href="#哈希表——计算式查找法" class="headerlink" title="哈希表——计算式查找法"></a>哈希表——计算式查找法</h3></li>
</ol>
<ul>
<li>哈希法又称散列法、杂凑法或关键字地址计算法等，相应的表称为哈希表或散列表；</li>
<li>方法的基本思想：在元素的关键字Key和元素的存储位置p之间建立一个对应关系H，使得p=H(Key)，H称为哈希函数(散列函数)，是一个压缩映象；</li>
<li>当查找关键字为key的元素时，利用哈希函数计算出该元素的存储位置p=H(key)，从而达到按关键字直接存取元素的目的；</li>
<li>H(Key)也称为哈希地址(又称散列地址)。把如此构造的表存储结构称为哈希表。</li>
<li>装填因子α(Load Factor):<br>$α= \frac nm$  n: 表中关键字数；m: 表长。</li>
</ul>
</blockquote>
<ol>
<li><p>构造方法：</p>
<ul>
<li>直接定址：<br>$H(key) = key$ 或 $H(key) = a*key+b$</li>
<li>数字分析：提取关键字中取值较均匀的数字位作为哈希地址的方法。它适合于所有关键字值都已知的情况,并需要对关键字中每一位的取值分布情况进行分析。<br>$H(key)=H(d1d2d3…d7d8)=d4d7$<br><img src="/images/structure/9-3.png" alt="alt"></li>
<li>除留余数法：假设哈希表长为m, 则哈希函数为:<br>$H(key) =key\%p— (p为小于等于m的最大素数)$<br><img src="/images/structure/9-4.png" alt="alt"></li>
<li>伪随机数法</li>
<li>平方取中法</li>
<li>折叠法（关键字分割成位数相同的几部分，然后取这几部分的叠加和）</li>
</ul>
</li>
<li><p>解决冲突：</p>
<ul>
<li>开放定址法：<br>$H_i = ( H(Key)+d_i )\%m$<br>di: 称为增量序列<br><img src="/images/structure/9-5.png" alt="alt"></li>
<li>再造哈希法</li>
<li>建立公共溢出区</li>
<li>ASL计算 <a href="https://blog.csdn.net/txd751466382/article/details/80851543" target="_blank" rel="noopener">https://blog.csdn.net/txd751466382/article/details/80851543</a><br><img src="/images/structure/9-5.png" alt="alt"></li>
</ul>
</li>
</ol>
<ul>
<li>哈希表的装填因子  表明了表中的装满程度。越大，说明表越满，再插入新元素时发生冲突的可能性就越大。</li>
<li>哈希的查找性能，即平均查找长度依赖于哈希表的装填因子，不直接依赖于 n 或 m。</li>
<li>不论表的长度有多大，总能选择一个合适的装填因子，以把平均查找长度限制在一定范围内。</li>
</ul>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/833/" rel="tag"># 833</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/10/27/camera/" rel="next" title="方向设计">
                <i class="fa fa-chevron-left"></i> 方向设计
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/11/24/combine/" rel="prev" title="计组复习笔记">
                计组复习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/own/avatar.jpg"
                alt="Steins.lei" />
            
              <p class="site-author-name" itemprop="name">Steins.lei</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#线性表"><span class="nav-number">1.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线性表的概念"><span class="nav-number">1.1.</span> <span class="nav-text">线性表的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性表的操作"><span class="nav-number">1.2.</span> <span class="nav-text">线性表的操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序表"><span class="nav-number">1.3.</span> <span class="nav-text">顺序表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#存储结构"><span class="nav-number">1.3.1.</span> <span class="nav-text">存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实现方法"><span class="nav-number">1.3.2.</span> <span class="nav-text">实现方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">1.3.3.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链表"><span class="nav-number">1.4.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#链表的概念"><span class="nav-number">1.4.1.</span> <span class="nav-text">链表的概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序表与链表的比较"><span class="nav-number">1.5.</span> <span class="nav-text">顺序表与链表的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#栈和队列"><span class="nav-number">2.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础概念与基本操作"><span class="nav-number">2.1.</span> <span class="nav-text">基础概念与基本操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的概念（stack）"><span class="nav-number">2.1.1.</span> <span class="nav-text">栈的概念（stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的基本操作"><span class="nav-number">2.1.2.</span> <span class="nav-text">栈的基本操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列的概念（stack）"><span class="nav-number">2.1.3.</span> <span class="nav-text">队列的概念（stack）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列的基本操作"><span class="nav-number">2.1.4.</span> <span class="nav-text">队列的基本操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序存储结构与链式存储结构"><span class="nav-number">2.2.</span> <span class="nav-text">顺序存储结构与链式存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的顺序存储结构与链式存储结构"><span class="nav-number">2.2.1.</span> <span class="nav-text">栈的顺序存储结构与链式存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列的顺序存储结构与链式存储结构"><span class="nav-number">2.2.2.</span> <span class="nav-text">队列的顺序存储结构与链式存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈和队列的应用"><span class="nav-number">2.3.</span> <span class="nav-text">栈和队列的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的应用一——括号匹配"><span class="nav-number">2.3.1.</span> <span class="nav-text">栈的应用一——括号匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的应用二——算式求值"><span class="nav-number">2.3.2.</span> <span class="nav-text">栈的应用二——算式求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#栈的应用三——递归"><span class="nav-number">2.3.3.</span> <span class="nav-text">栈的应用三——递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#队列的应用"><span class="nav-number">2.3.4.</span> <span class="nav-text">队列的应用</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#串"><span class="nav-number">3.</span> <span class="nav-text">串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#串的概率和操作"><span class="nav-number">3.1.</span> <span class="nav-text">串的概率和操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#串的基本概念"><span class="nav-number">3.1.1.</span> <span class="nav-text">串的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#串的基本操作"><span class="nav-number">3.1.2.</span> <span class="nav-text">串的基本操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#串的匹配"><span class="nav-number">3.2.</span> <span class="nav-text">串的匹配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#朴素匹配"><span class="nav-number">3.2.1.</span> <span class="nav-text">朴素匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP"><span class="nav-number">3.2.2.</span> <span class="nav-text">KMP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#KMP优化"><span class="nav-number">3.2.3.</span> <span class="nav-text">KMP优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码："><span class="nav-number">3.3.</span> <span class="nav-text">代码：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">4.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#树-1"><span class="nav-number">4.1.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#树的基本概念"><span class="nav-number">4.1.1.</span> <span class="nav-text">树的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点之间的关系"><span class="nav-number">4.1.2.</span> <span class="nav-text">节点之间的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#节点、树的属性"><span class="nav-number">4.1.3.</span> <span class="nav-text">节点、树的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树的性质"><span class="nav-number">4.1.4.</span> <span class="nav-text">树的性质</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二叉树"><span class="nav-number">4.2.</span> <span class="nav-text">二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的基本概念"><span class="nav-number">4.2.1.</span> <span class="nav-text">二叉树的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特殊二叉树"><span class="nav-number">4.2.2.</span> <span class="nav-text">特殊二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的性质"><span class="nav-number">4.2.3.</span> <span class="nav-text">二叉树的性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的存储结构"><span class="nav-number">4.2.4.</span> <span class="nav-text">二叉树的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二叉树的遍历"><span class="nav-number">4.2.5.</span> <span class="nav-text">二叉树的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线索二叉树的基本概念和构造"><span class="nav-number">4.2.6.</span> <span class="nav-text">线索二叉树的基本概念和构造</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#树、森林"><span class="nav-number">4.3.</span> <span class="nav-text">树、森林</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#树的存储结构"><span class="nav-number">4.3.1.</span> <span class="nav-text">树的存储结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#树、森林、二叉树的转换"><span class="nav-number">4.3.2.</span> <span class="nav-text">树、森林、二叉树的转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈夫曼数"><span class="nav-number">4.4.</span> <span class="nav-text">哈夫曼数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#图"><span class="nav-number">5.</span> <span class="nav-text">图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#图的基本概念"><span class="nav-number">5.1.</span> <span class="nav-text">图的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的存储结构"><span class="nav-number">5.2.</span> <span class="nav-text">图的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接矩阵"><span class="nav-number">5.2.1.</span> <span class="nav-text">邻接矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接表"><span class="nav-number">5.2.2.</span> <span class="nav-text">邻接表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#十字链表"><span class="nav-number">5.2.3.</span> <span class="nav-text">十字链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#邻接多重表"><span class="nav-number">5.2.4.</span> <span class="nav-text">邻接多重表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的遍历"><span class="nav-number">5.3.</span> <span class="nav-text">图的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#深度优先遍历-DFS"><span class="nav-number">5.3.1.</span> <span class="nav-text">深度优先遍历-DFS</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广度优先遍历-BFS"><span class="nav-number">5.3.2.</span> <span class="nav-text">广度优先遍历-BFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图的应用"><span class="nav-number">5.4.</span> <span class="nav-text">图的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最小生成树"><span class="nav-number">5.4.1.</span> <span class="nav-text">最小生成树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拓扑排序"><span class="nav-number">5.4.2.</span> <span class="nav-text">拓扑排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关键路径"><span class="nav-number">5.4.3.</span> <span class="nav-text">关键路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最短路径"><span class="nav-number">5.4.4.</span> <span class="nav-text">最短路径</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找"><span class="nav-number">6.</span> <span class="nav-text">查找</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#查找的基本概念"><span class="nav-number">6.1.</span> <span class="nav-text">查找的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态查找表——基于线性表的查找法"><span class="nav-number">6.2.</span> <span class="nav-text">静态查找表——基于线性表的查找法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态查找表——基于树表的查找法"><span class="nav-number">6.3.</span> <span class="nav-text">动态查找表——基于树表的查找法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表——计算式查找法"><span class="nav-number">6.4.</span> <span class="nav-text">哈希表——计算式查找法</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Steins.lei</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"log":false});</script></body>
</html>
